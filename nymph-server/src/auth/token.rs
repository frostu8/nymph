//! JSON Web Token authentication.

use axum::extract::{FromRef, FromRequestParts};

use http::{header, request::Parts};

use jsonwebtoken::{
    Algorithm, Header, TokenData, Validation, decode, encode, errors::Error as JwtError,
};

use chrono::{DateTime, TimeDelta, Utc};

use derive_more::{Deref, Display, From, Into};

use serde::{Deserialize, Deserializer, Serialize, Serializer, de::Error as _};

use crate::app::{AppError, AppErrorKind, AppState, SigningKeys};

/// Token-based authentication.
#[derive(Clone, Debug)]
pub struct TokenAuthentication {
    /// The id of the authorized user.
    pub sub: Sub,
    /// The expiry time of the authorization.
    ///
    /// May be `None` if the user was authenticated through mTLS.
    pub exp: Option<DateTime<Utc>>,
    /// If the token used to authenticate this request was a proxy token.
    pub proxy: bool,
}

impl<S> FromRequestParts<S> for TokenAuthentication
where
    AppState: FromRef<S>,
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        // if the result has been cached, simply return the cache
        if let Some(auth) = parts.extensions.get::<TokenAuthentication>() {
            return Ok(auth.clone());
        }

        // find authorization header
        let token = parts
            .headers
            .get(header::AUTHORIZATION)
            .and_then(|s| s.to_str().ok())
            .and_then(|s| s.strip_prefix("Bearer"))
            .map(|s| s.trim());

        let auth = if let Some(token) = token {
            let state = AppState::from_ref(state);

            // decode jwt
            Claims::decode(token, &state.keys)
                .map(|claims| TokenAuthentication {
                    sub: claims.sub(),
                    exp: Some(
                        DateTime::from_timestamp_secs(claims.exp())
                            .expect("valid signed timestamp"),
                    ),
                    proxy: claims.proxy(),
                })
                .map_err(AppErrorKind::InvalidAuthorization)?
        } else {
            // bail because unauthorized
            return Err(AppErrorKind::Unauthorized.into());
        };

        // cache to extensions
        parts.extensions.insert(auth.clone());

        Ok(auth)
    }
}

/// The claims used by JWTs generated by Nymph.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Claims {
    sub: Sub,
    exp: i64,
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    proxy: bool,
}

impl Claims {
    /// Creates a [`ClaimsBuilder`] for a subject.
    pub fn builder(sub: impl Into<Sub>) -> ClaimsBuilder {
        ClaimsBuilder::new(sub)
    }

    /// The subject of the claim.
    ///
    /// This is the id of the user the token is authorizing for.
    pub fn sub(&self) -> Sub {
        self.sub
    }

    /// The expiry time of the claim.
    pub fn exp(&self) -> i64 {
        self.exp
    }

    /// `true` if the token is a proxy token.
    pub fn proxy(&self) -> bool {
        self.proxy
    }

    /// Grants a token.
    pub fn encode(&self, keys: &SigningKeys) -> Result<String, JwtError> {
        let header = Header::new(Algorithm::HS256);

        encode(&header, self, &keys.encoding)
    }

    /// Decodes a token passed as a cookie.
    pub fn decode(token: &str, keys: &SigningKeys) -> Result<Claims, JwtError> {
        let validation = Validation::new(Algorithm::HS256);

        decode(token, &keys.decoding, &validation).map(|token: TokenData<Claims>| token.claims)
    }
}

/// A builder for authorization claims.
#[derive(Debug)]
pub struct ClaimsBuilder {
    sub: Sub,
    exp: TimeDelta,
    proxy: bool,
}

impl ClaimsBuilder {
    /// Creates a new `ClaimsBuilder` for a username.
    pub fn new(sub: impl Into<Sub>) -> ClaimsBuilder {
        ClaimsBuilder {
            sub: sub.into(),
            exp: TimeDelta::days(1),
            proxy: false,
        }
    }

    /// Sets the expiry time of the claims. By default, this is one day.
    pub fn exp(self, delta: TimeDelta) -> ClaimsBuilder {
        ClaimsBuilder { exp: delta, ..self }
    }

    /// Marks the token as a proxy token.
    pub fn proxy(self, proxy: bool) -> ClaimsBuilder {
        ClaimsBuilder { proxy, ..self }
    }

    /// Builds the claims for the [`Claims`] struct.
    pub fn build(self) -> Claims {
        let ClaimsBuilder { sub, exp, proxy } = self;

        Claims {
            sub,
            exp: (Utc::now().naive_utc() + exp).and_utc().timestamp() as i64,
            proxy,
        }
    }
}

/// Claims subject.
///
/// This is the id of the subject (the user).
#[derive(Clone, Copy, Debug, Display, Deref, From, Into)]
pub struct Sub(i32);

impl Sub {
    pub fn get(&self) -> i32 {
        self.0
    }
}

impl<'de> Deserialize<'de> for Sub {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)
            .and_then(|s| s.parse::<i32>().map_err(|e| D::Error::custom(e)))
            .map(|id| Sub(id))
    }
}

impl Serialize for Sub {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.0.to_string().serialize(serializer)
    }
}
